import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  Animated,
  TouchableOpacity,
  ViewStyle 
} from 'react-native';
import { useTheme } from './providers/ThemeProvider';
import { useHaptics } from './providers/HapticsProvider';
import { 
  spacing, 
  radii, 
  typography, 
  durations,
  zIndices,
  shadows
} from './constants/ui';

export type ToastVariant = 'default' | 'success' | 'error' | 'info' | 'warning';
export type ToastPosition = 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';

export interface ToastProps {
  variant?: ToastVariant;
  position?: ToastPosition;
  title?: string;
  description?: string;
  action?: {
    label: string;
    onPress: () => void;
  };
  onClose?: () => void;
  duration?: number;
  showCloseButton?: boolean;
  icon?: React.ReactNode;
  style?: ViewStyle;
  enableHaptics?: boolean;
  visible?: boolean;
}

export function Toast({
  variant = 'default',
  position = 'top',
  title,
  description,
  action,
  onClose,
  duration = durations.long,
  showCloseButton = true,
  icon,
  style,
  enableHaptics = true,
  visible = true,
}: ToastProps) {
  const { currentColors } = useTheme();
  const { triggerHaptic } = useHaptics();
  const [isVisible, setIsVisible] = useState(visible);
  const fadeAnim = useState(new Animated.Value(0))[0];
  const translateY = useState(new Animated.Value(position.includes('top') ? -20 : 20))[0];

  useEffect(() => {
    if (visible) {
      setIsVisible(true);
      
      // Trigger haptic feedback based on variant
      if (enableHaptics) {
        switch (variant) {
          case 'success':
            triggerHaptic('notificationSuccess');
            break;
          case 'error':
            triggerHaptic('notificationError');
            break;
          case 'warning':
            triggerHaptic('notificationWarning');
            break;
          default:
            triggerHaptic('impactLight');
            break;
        }
      }

      // Animate in
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: durations.normal,
          useNativeDriver: true,
        }),
        Animated.timing(translateY, {
          toValue: 0,
          duration: durations.normal,
          useNativeDriver: true,
        }),
      ]).start();

      // Auto-hide if duration is set
      if (duration > 0) {
        const timer = setTimeout(() => {
          handleClose();
        }, duration);

        return () => clearTimeout(timer);
      }
    }
  }, [visible, duration, enableHaptics, variant]);

  const handleClose = () => {
    // Animate out
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 0,
        duration: durations.fast,
        useNativeDriver: true,
      }),
      Animated.timing(translateY, {
        toValue: position.includes('top') ? -20 : 20,
        duration: durations.fast,
        useNativeDriver: true,
      }),
    ]).start(() => {
      setIsVisible(false);
      onClose?.();
    });
  };

  const getVariantStyles = () => {
    switch (variant) {
      case 'success':
        return {
          backgroundColor: currentColors.success,
          textColor: currentColors.successForeground,
          iconColor: currentColors.successForeground,
        };
      case 'error':
        return {
          backgroundColor: currentColors.destructive,
          textColor: currentColors.destructiveForeground,
          iconColor: currentColors.destructiveForeground,
        };
      case 'info':
        return {
          backgroundColor: currentColors.info,
          textColor: currentColors.infoForeground,
          iconColor: currentColors.infoForeground,
        };
      case 'warning':
        return {
          backgroundColor: currentColors.warning,
          textColor: currentColors.warningForeground,
          iconColor: currentColors.warningForeground,
        };
      default:
        return {
          backgroundColor: currentColors.background,
          textColor: currentColors.foreground,
          iconColor: currentColors.foreground,
        };
    }
  };

  const getPositionStyles = () => {
    const basePosition = {
      position: 'absolute' as const,
      zIndex: zIndices.toast,
    };

    switch (position) {
      case 'top':
        return {
          ...basePosition,
          top: spacing[4],
          left: spacing[4],
          right: spacing[4],
        };
      case 'bottom':
        return {
          ...basePosition,
          bottom: spacing[4],
          left: spacing[4],
          right: spacing[4],
        };
      case 'top-left':
        return {
          ...basePosition,
          top: spacing[4],
          left: spacing[4],
          maxWidth: 300,
        };
      case 'top-right':
        return {
          ...basePosition,
          top: spacing[4],
          right: spacing[4],
          maxWidth: 300,
        };
      case 'bottom-left':
        return {
          ...basePosition,
          bottom: spacing[4],
          left: spacing[4],
          maxWidth: 300,
        };
      case 'bottom-right':
        return {
          ...basePosition,
          bottom: spacing[4],
          right: spacing[4],
          maxWidth: 300,
        };
      default:
        return basePosition;
    }
  };

  const variantStyles = getVariantStyles();
  const positionStyles = getPositionStyles();

  const styles = StyleSheet.create({
    container: {
      ...positionStyles,
      backgroundColor: variantStyles.backgroundColor,
      borderRadius: radii.md,
      paddingVertical: spacing[3],
      paddingHorizontal: spacing[4],
      shadowColor: '#000000',
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.12,
      shadowRadius: 8,
      elevation: 8,
      flexDirection: 'row',
      alignItems: 'flex-start',
      gap: spacing[3],
    },
    content: {
      flex: 1,
      gap: spacing[1],
    },
    title: {
      fontSize: typography.fontSizes.md,
      fontWeight: typography.fontWeights.semiBold,
      color: variantStyles.textColor,
    },
    description: {
      fontSize: typography.fontSizes.sm,
      color: variantStyles.textColor,
      lineHeight: typography.lineHeights.relaxed * typography.fontSizes.sm,
    },
    actions: {
      flexDirection: 'row',
      alignItems: 'center',
      gap: spacing[2],
      marginTop: spacing[2],
    },
    actionButton: {
      paddingVertical: spacing[1],
      paddingHorizontal: spacing[2],
    },
    actionText: {
      fontSize: typography.fontSizes.sm,
      fontWeight: typography.fontWeights.medium,
      color: currentColors.primary,
    },
    closeButton: {
      padding: spacing[1],
      marginTop: -spacing[1],
      marginRight: -spacing[1],
    },
    closeText: {
      fontSize: typography.fontSizes.lg,
      color: variantStyles.iconColor,
      fontWeight: typography.fontWeights.bold,
    },
    icon: {
      marginTop: spacing[0.5],
    },
    iconText: {
      fontSize: typography.fontSizes.lg,
      color: variantStyles.iconColor,
    },
  });

  const getIcon = () => {
    switch (variant) {
      case 'success':
        return '✓';
      case 'error':
        return '✕';
      case 'warning':
        return '⚠';
      case 'info':
        return 'ℹ';
      default:
        return '•';
    }
  };

  if (!isVisible) {
    return null;
  }

  return (
    <Animated.View
      style={[
        styles.container,
        {
          opacity: fadeAnim,
          transform: [{ translateY }],
        },
        style,
      ]}
      accessible={true}
      accessibilityLabel="Toast notification"
      accessibilityHint="Displays a temporary message"
      accessibilityRole="alert"
    >
      {/* Icon */}
      <View style={styles.icon}>
        {icon || (
          <Text style={styles.iconText}>
            {getIcon()}
          </Text>
        )}
      </View>

      {/* Content */}
      <View style={styles.content}>
        {title && (
          <Text style={styles.title}>
            {title}
          </Text>
        )}
        
        {description && (
          <Text style={styles.description}>
            {description}
          </Text>
        )}

        {/* Actions */}
        {action && (
          <View style={styles.actions}>
            <TouchableOpacity
              style={styles.actionButton}
              onPress={action.onPress}
            >
              <Text style={styles.actionText}>
                {action.label}
              </Text>
            </TouchableOpacity>
          </View>
        )}
      </View>

      {/* Close Button */}
      {showCloseButton && (
        <TouchableOpacity
          style={styles.closeButton}
          onPress={handleClose}
          accessible={true}
          accessibilityLabel="Close toast"
          accessibilityRole="button"
        >
          <Text style={styles.closeText}>
            ×
          </Text>
        </TouchableOpacity>
      )}
    </Animated.View>
  );
}

// Toast Provider for managing multiple toasts
export interface ToastContextValue {
  showToast: (props: Omit<ToastProps, 'visible'>) => void;
}

const ToastContext = React.createContext<ToastContextValue | null>(null);

export function useToast() {
  const context = React.useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = useState<Array<ToastProps & { id: string }>>([]);

  const showToast = (props: Omit<ToastProps, 'visible'>) => {
    const id = Math.random().toString(36).substring(2);
    const toast = { ...props, id, visible: true };

    setToasts(prev => [...prev, toast]);

    // Auto-remove toast
    const duration = props.duration || durations.long;
    if (duration > 0) {
      setTimeout(() => {
        setToasts(prev => prev.filter(t => t.id !== id));
      }, duration + durations.normal); // Add animation time
    }
  };

  const removeToast = (id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  };

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      {toasts.map(toast => (
        <Toast
          key={toast.id}
          {...toast}
          onClose={() => removeToast(toast.id)}
        />
      ))}
    </ToastContext.Provider>
  );
}